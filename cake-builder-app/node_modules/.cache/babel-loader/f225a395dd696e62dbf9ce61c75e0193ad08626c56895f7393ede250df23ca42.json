{"ast":null,"code":"var _jsxFileName = \"D:\\\\M\\xF4n h\\u1ECDc\\\\C\\xF4ng ngh\\u1EC7 Java\\\\cake-builder-app\\\\src\\\\components\\\\CakeCanvas.js\",\n  _s = $RefreshSig$();\n// import React, { forwardRef } from 'react'; // Import forwardRef\n// import './CakeCanvas.css';\n// import Layer from './Layer';\n\n// const CANVAS_WIDTH = 300;\n// const CANVAS_HEIGHT = 300;\n// // Vị trí gốc cho lớp bánh đầu tiên (hình dạng/màu sắc cơ bản)\n// // Đặt BASE_X và BASE_Y để hình ảnh 100x100px được căn giữa trong canvas 300x300px\n// // (300 / 2) - (100 / 2) = 150 - 50 = 100\n// const BASE_X = CANVAS_WIDTH / 2;\n// const BASE_Y = CANVAS_HEIGHT / 2 + 50; // Điều chỉnh vị trí trung tâm theo chiều dọc để bánh không quá cao\n\n// // Sử dụng forwardRef để có thể truyền ref từ component cha (App.js)\n// // forwardRef nhận một hàm component, và hàm này sẽ nhận props và ref như các đối số\n// const CakeCanvas = forwardRef(({ layers, numLayers, onDrop }, ref) => { // Thêm ref vào đối số\n//     return (\n//         <div\n//             className=\"cake-canvas\"\n//             style={{ width: `${CANVAS_WIDTH}px`, height: `${CANVAS_HEIGHT}px` }}\n//             ref={ref} // Gán ref vào div canvas\n//             onDrop={onDrop} // Gán sự kiện onDrop từ props\n//             onDragOver={(e) => e.preventDefault()} // Ngăn chặn hành vi mặc định để cho phép thả\n//         >\n//             {layers.map((layer, index) => {\n//                 // Khởi tạo vị trí và kích thước mặc định cho mỗi lớp là 100x100px\n//                 // x, y là góc trên bên trái của hình ảnh 100x100px, được căn giữa tại BASE_X, BASE_Y\n//                 let x = BASE_X - 50; // 50 là một nửa chiều rộng/cao mặc định (100px)\n//                 let y = BASE_Y - 50;\n//                 let width = 100;\n//                 let height = 100;\n//                 let zIndex = index + 1; // Đảm bảo các lớp mới hơn nằm trên các lớp cũ hơn\n\n//                 switch (layer.type) {\n//                     case 'shape':\n//                     case 'base':\n//                     case 'midCream':\n//                         // Các lớp này giữ nguyên kích thước 100x100px\n//                         // Vị trí được điều chỉnh tương ứng với lớp dưới\n//                         if (layer.type === 'midCream') {\n//                             y -= 22.6;\n//                         }\n//                         break;\n//                     case 'topColorSecondLayer':\n//                         // Màu sắc tầng 2: giảm kích thước xuống 80% và dịch chuyển theo yêu cầu\n//                         width *= 0.8;\n//                         height *= 0.8;\n//                         x += 37.6;\n//                         y -= 61.9;\n//                         break;\n//                     case 'topCream':\n//                         // Kem phủ: vị trí và kích thước khác nhau tùy thuộc vào số tầng\n//                         if (numLayers === 1) {\n//                             // Bánh 1 tầng: giữ nguyên 100x100px, dịch lên trên 22.6px\n//                             y -= 22.6;\n//                         } else if (numLayers === 2) {\n//                             // Bánh 2 tầng: giảm kích thước xuống 80% và dịch chuyển theo yêu cầu\n//                             width *= 0.8;\n//                             height *= 0.8;\n//                             x += 37.6;\n//                             y -= 61.9;\n//                         }\n//                         break;\n//                     case 'sugar':\n//                         // Đường mịn: vị trí và kích thước khác nhau tùy thuộc vào số tầng\n//                         if (numLayers === 1) {\n//                             // Bánh 1 tầng: giữ nguyên 100x100px, dịch lên trên 22.6px\n//                             y -= 22.6;\n//                         } else if (numLayers === 2) {\n//                             // Bánh 2 tầng: giảm kích thước xuống 80% và dịch chuyển theo yêu cầu\n//                             width *= 0.8;\n//                             height *= 0.8;\n//                             x += 37.6;\n//                             y -= 61.9;\n//                         }\n//                         break;\n//                     default:\n//                         break;\n//                 }\n\n//                 return (\n//                     <Layer\n//                         key={layer.type} // Sử dụng layer.type làm key để đảm bảo cập nhật đúng\n//                         src={layer.src}\n//                         alt={layer.type}\n//                         style={{\n//                             position: 'absolute',\n//                             left: `${x}px`,\n//                             top: `${y}px`,\n//                             width: `${width}px`,\n//                             height: `${height}px`,\n//                             zIndex: zIndex,\n//                         }}\n//                     />\n//                 );\n//             })}\n//         </div>\n//     );\n// });\n\n// // export default CakeCanvas;\n// import React, { forwardRef } from 'react'; // Import forwardRef\n// import './CakeCanvas.css';\n// import Layer from './Layer';\n\n// const CANVAS_WIDTH = 300;\n// const CANVAS_HEIGHT = 300;\n// // Định nghĩa tâm của khu vực hiển thị bánh trên canvas\n// const BASE_X_CENTER = CANVAS_WIDTH / 2;\n// const BASE_Y_CENTER = CANVAS_HEIGHT / 2 + 50; // Điều chỉnh vị trí trung tâm theo chiều dọc\n\n// // Sử dụng forwardRef để có thể truyền ref từ component cha (App.js)\n// const CakeCanvas = forwardRef(({ layers, numLayers, onDrop }, ref) => {\n//     return (\n//         <div\n//             className=\"cake-canvas\"\n//             style={{ width: `${CANVAS_WIDTH}px`, height: `${CANVAS_HEIGHT}px` }}\n//             ref={ref} // Gán ref vào div canvas\n//             onDrop={onDrop} // Gán sự kiện onDrop từ props\n//             onDragOver={(e) => e.preventDefault()} // Ngăn chặn hành vi mặc định để cho phép thả\n//         >\n//             {layers.map((layer, index) => {\n//                 let currentWidth = 100; // Kích thước mặc định cho tất cả các lớp\n//                 let currentHeight = 100; // Kích thước mặc định cho tất cả các lớp\n//                 let offsetX = 0; // Offset thêm vào vị trí X\n//                 let offsetY = 0; // Offset thêm vào vị trí Y\n\n//                 // Bước 1: Xác định kích thước thực tế của lớp hiện tại (100% hoặc 80%)\n//                 if (\n//                     layer.type === 'topColorSecondLayer' ||\n//                     (layer.type === 'topCream' && numLayers === 2) ||\n//                     (layer.type === 'sugar' && numLayers === 2)\n//                 ) {\n//                     currentWidth *= 0.8;\n//                     currentHeight *= 0.8;\n//                 }\n\n//                 // Bước 2: Tính toán vị trí góc trên bên trái ban đầu để căn giữa hình ảnh\n//                 // dựa trên kích thước hiện tại của nó (currentWidth, currentHeight)\n//                 let x = BASE_X_CENTER - (currentWidth / 2);\n//                 let y = BASE_Y_CENTER - (currentHeight / 2);\n\n//                 // Bước 3: Áp dụng các offset cụ thể mà bạn đã cung cấp\n//                 switch (layer.type) {\n//                     case 'midCream':\n//                         offsetY -= 22.6;\n//                         break;\n//                     case 'topColorSecondLayer':\n//                         offsetX += 37.6;\n//                         offsetY -= 61.9;\n//                         break;\n//                     case 'topCream':\n//                         if (numLayers === 1) {\n//                             offsetY -= 22.6;\n//                         } else if (numLayers === 2) {\n//                             offsetX += 37.6;\n//                             offsetY -= 61.9;\n//                         }\n//                         break;\n//                     case 'sugar':\n//                         if (numLayers === 1) {\n//                             offsetY -= 22.6;\n//                         } else if (numLayers === 2) {\n//                             offsetX += 37.6;\n//                             offsetY -= 61.9;\n//                         }\n//                         break;\n//                     default:\n//                         break;\n//                 }\n\n//                 // Bước 4: Áp dụng tổng các offset vào vị trí cuối cùng\n//                 x += offsetX;\n//                 y += offsetY;\n\n//                 let zIndex = index + 1; // Đảm bảo các lớp mới hơn nằm trên các lớp cũ hơn\n\n//                 return (\n//                     <Layer\n//                         key={layer.type} // Sử dụng layer.type làm key để đảm bảo cập nhật đúng\n//                         src={layer.src}\n//                         alt={layer.type}\n//                         style={{\n//                             position: 'absolute',\n//                             left: `${x}px`,\n//                             top: `${y}px`,\n//                             width: `${currentWidth}px`,\n//                             height: `${currentHeight}px`,\n//                             zIndex: zIndex,\n//                         }}\n//                     />\n//                 );\n//             })}\n//         </div>\n//     );\n// });\n\n// export default CakeCanvas;\n\nimport React, { forwardRef, useState, useEffect } from 'react';\nimport './CakeCanvas.css';\nimport Layer from './Layer';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CANVAS_WIDTH = 300;\nconst CANVAS_HEIGHT = 300;\nconst CakeCanvas = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  layers,\n  numLayers,\n  onDrop\n}, ref) => {\n  _s();\n  const [imageSizes, setImageSizes] = useState({});\n\n  // Hàm lấy kích thước thực tế của ảnh sau khi tải\n  const getImageDimensions = src => {\n    return new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        resolve({\n          width: img.width,\n          height: img.height\n        });\n      };\n      img.src = src;\n    });\n  };\n\n  // Lấy kích thước của tất cả các ảnh khi component mount hoặc khi layers thay đổi\n  useEffect(() => {\n    const fetchSizes = async () => {\n      const sizes = {};\n      for (const layer of layers) {\n        if (layer.src && !sizes[layer.src]) {\n          const dimensions = await getImageDimensions(layer.src);\n          sizes[layer.src] = dimensions;\n        }\n      }\n      setImageSizes(prevSizes => ({\n        ...prevSizes,\n        ...sizes\n      }));\n    };\n    fetchSizes();\n  }, [layers]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"cake-canvas\",\n    style: {\n      width: `${CANVAS_WIDTH}px`,\n      height: `${CANVAS_HEIGHT}px`\n    },\n    ref: ref,\n    onDrop: onDrop,\n    onDragOver: e => e.preventDefault(),\n    children: layers.map((layer, index) => {\n      const originalSize = imageSizes[layer.src] || {\n        width: 100,\n        height: 100\n      };\n      let displayWidth = originalSize.width;\n      let displayHeight = originalSize.height;\n      const centerX = CANVAS_WIDTH / 2;\n      const centerY = CANVAS_HEIGHT / 2 + 50;\n      let offsetX = 0;\n      let offsetY = 0;\n\n      // Giảm kích thước hiển thị xuống 80% cho một số lớp\n      if (layer.type === 'topColorSecondLayer' || layer.type === 'topCream' && numLayers === 2 || layer.type === 'sugar' && numLayers === 2) {\n        displayWidth *= 0.8;\n        displayHeight *= 0.8;\n      }\n\n      // Tính toán vị trí để căn giữa *sau khi* đã điều chỉnh kích thước hiển thị\n      let x = centerX - displayWidth / 2;\n      let y = centerY - displayHeight / 2;\n      let zIndex = index + 1;\n\n      // Áp dụng offsets của bạn dựa trên layer.type\n      switch (layer.type) {\n        case 'midCream':\n          offsetY -= 22.6;\n          break;\n        case 'topColorSecondLayer':\n          offsetX += 37.6;\n          offsetY -= 61.9;\n          break;\n        case 'topCream':\n          offsetY -= numLayers === 1 ? 22.6 : 61.9; // Cần bạn xác nhận offset chính xác\n          break;\n        case 'sugar':\n          // offsetY -= (numLayers === 1 ? 22.6 : 61.9);\n          offsetY -= numLayers === 1 ? 23.6 : 61.9; // Cần bạn xác nhận offset chính xác\n          break;\n        // Thêm các case khác nếu cần\n      }\n      x += offsetX;\n      y += offsetY;\n      return /*#__PURE__*/_jsxDEV(Layer, {\n        src: layer.src,\n        alt: layer.type,\n        style: {\n          position: 'absolute',\n          left: `${x}px`,\n          top: `${y}px`,\n          width: `${displayWidth}px`,\n          height: `${displayHeight}px`,\n          zIndex: zIndex\n        }\n      }, layer.type, false, {\n        fileName: _jsxFileName,\n        lineNumber: 292,\n        columnNumber: 21\n      }, this);\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 237,\n    columnNumber: 9\n  }, this);\n}, \"/3FTaMFiKEcQRmcHgVmCa6Hs16k=\")), \"/3FTaMFiKEcQRmcHgVmCa6Hs16k=\");\n_c2 = CakeCanvas;\nexport default CakeCanvas;\nvar _c, _c2;\n$RefreshReg$(_c, \"CakeCanvas$forwardRef\");\n$RefreshReg$(_c2, \"CakeCanvas\");","map":{"version":3,"names":["React","forwardRef","useState","useEffect","Layer","jsxDEV","_jsxDEV","CANVAS_WIDTH","CANVAS_HEIGHT","CakeCanvas","_s","_c","layers","numLayers","onDrop","ref","imageSizes","setImageSizes","getImageDimensions","src","Promise","resolve","img","Image","onload","width","height","fetchSizes","sizes","layer","dimensions","prevSizes","className","style","onDragOver","e","preventDefault","children","map","index","originalSize","displayWidth","displayHeight","centerX","centerY","offsetX","offsetY","type","x","y","zIndex","alt","position","left","top","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["D:/Môn học/Công nghệ Java/cake-builder-app/src/components/CakeCanvas.js"],"sourcesContent":["// import React, { forwardRef } from 'react'; // Import forwardRef\r\n// import './CakeCanvas.css';\r\n// import Layer from './Layer';\r\n\r\n// const CANVAS_WIDTH = 300;\r\n// const CANVAS_HEIGHT = 300;\r\n// // Vị trí gốc cho lớp bánh đầu tiên (hình dạng/màu sắc cơ bản)\r\n// // Đặt BASE_X và BASE_Y để hình ảnh 100x100px được căn giữa trong canvas 300x300px\r\n// // (300 / 2) - (100 / 2) = 150 - 50 = 100\r\n// const BASE_X = CANVAS_WIDTH / 2;\r\n// const BASE_Y = CANVAS_HEIGHT / 2 + 50; // Điều chỉnh vị trí trung tâm theo chiều dọc để bánh không quá cao\r\n\r\n// // Sử dụng forwardRef để có thể truyền ref từ component cha (App.js)\r\n// // forwardRef nhận một hàm component, và hàm này sẽ nhận props và ref như các đối số\r\n// const CakeCanvas = forwardRef(({ layers, numLayers, onDrop }, ref) => { // Thêm ref vào đối số\r\n//     return (\r\n//         <div\r\n//             className=\"cake-canvas\"\r\n//             style={{ width: `${CANVAS_WIDTH}px`, height: `${CANVAS_HEIGHT}px` }}\r\n//             ref={ref} // Gán ref vào div canvas\r\n//             onDrop={onDrop} // Gán sự kiện onDrop từ props\r\n//             onDragOver={(e) => e.preventDefault()} // Ngăn chặn hành vi mặc định để cho phép thả\r\n//         >\r\n//             {layers.map((layer, index) => {\r\n//                 // Khởi tạo vị trí và kích thước mặc định cho mỗi lớp là 100x100px\r\n//                 // x, y là góc trên bên trái của hình ảnh 100x100px, được căn giữa tại BASE_X, BASE_Y\r\n//                 let x = BASE_X - 50; // 50 là một nửa chiều rộng/cao mặc định (100px)\r\n//                 let y = BASE_Y - 50;\r\n//                 let width = 100;\r\n//                 let height = 100;\r\n//                 let zIndex = index + 1; // Đảm bảo các lớp mới hơn nằm trên các lớp cũ hơn\r\n\r\n//                 switch (layer.type) {\r\n//                     case 'shape':\r\n//                     case 'base':\r\n//                     case 'midCream':\r\n//                         // Các lớp này giữ nguyên kích thước 100x100px\r\n//                         // Vị trí được điều chỉnh tương ứng với lớp dưới\r\n//                         if (layer.type === 'midCream') {\r\n//                             y -= 22.6;\r\n//                         }\r\n//                         break;\r\n//                     case 'topColorSecondLayer':\r\n//                         // Màu sắc tầng 2: giảm kích thước xuống 80% và dịch chuyển theo yêu cầu\r\n//                         width *= 0.8;\r\n//                         height *= 0.8;\r\n//                         x += 37.6;\r\n//                         y -= 61.9;\r\n//                         break;\r\n//                     case 'topCream':\r\n//                         // Kem phủ: vị trí và kích thước khác nhau tùy thuộc vào số tầng\r\n//                         if (numLayers === 1) {\r\n//                             // Bánh 1 tầng: giữ nguyên 100x100px, dịch lên trên 22.6px\r\n//                             y -= 22.6;\r\n//                         } else if (numLayers === 2) {\r\n//                             // Bánh 2 tầng: giảm kích thước xuống 80% và dịch chuyển theo yêu cầu\r\n//                             width *= 0.8;\r\n//                             height *= 0.8;\r\n//                             x += 37.6;\r\n//                             y -= 61.9;\r\n//                         }\r\n//                         break;\r\n//                     case 'sugar':\r\n//                         // Đường mịn: vị trí và kích thước khác nhau tùy thuộc vào số tầng\r\n//                         if (numLayers === 1) {\r\n//                             // Bánh 1 tầng: giữ nguyên 100x100px, dịch lên trên 22.6px\r\n//                             y -= 22.6;\r\n//                         } else if (numLayers === 2) {\r\n//                             // Bánh 2 tầng: giảm kích thước xuống 80% và dịch chuyển theo yêu cầu\r\n//                             width *= 0.8;\r\n//                             height *= 0.8;\r\n//                             x += 37.6;\r\n//                             y -= 61.9;\r\n//                         }\r\n//                         break;\r\n//                     default:\r\n//                         break;\r\n//                 }\r\n\r\n//                 return (\r\n//                     <Layer\r\n//                         key={layer.type} // Sử dụng layer.type làm key để đảm bảo cập nhật đúng\r\n//                         src={layer.src}\r\n//                         alt={layer.type}\r\n//                         style={{\r\n//                             position: 'absolute',\r\n//                             left: `${x}px`,\r\n//                             top: `${y}px`,\r\n//                             width: `${width}px`,\r\n//                             height: `${height}px`,\r\n//                             zIndex: zIndex,\r\n//                         }}\r\n//                     />\r\n//                 );\r\n//             })}\r\n//         </div>\r\n//     );\r\n// });\r\n\r\n// // export default CakeCanvas;\r\n// import React, { forwardRef } from 'react'; // Import forwardRef\r\n// import './CakeCanvas.css';\r\n// import Layer from './Layer';\r\n\r\n// const CANVAS_WIDTH = 300;\r\n// const CANVAS_HEIGHT = 300;\r\n// // Định nghĩa tâm của khu vực hiển thị bánh trên canvas\r\n// const BASE_X_CENTER = CANVAS_WIDTH / 2;\r\n// const BASE_Y_CENTER = CANVAS_HEIGHT / 2 + 50; // Điều chỉnh vị trí trung tâm theo chiều dọc\r\n\r\n// // Sử dụng forwardRef để có thể truyền ref từ component cha (App.js)\r\n// const CakeCanvas = forwardRef(({ layers, numLayers, onDrop }, ref) => {\r\n//     return (\r\n//         <div\r\n//             className=\"cake-canvas\"\r\n//             style={{ width: `${CANVAS_WIDTH}px`, height: `${CANVAS_HEIGHT}px` }}\r\n//             ref={ref} // Gán ref vào div canvas\r\n//             onDrop={onDrop} // Gán sự kiện onDrop từ props\r\n//             onDragOver={(e) => e.preventDefault()} // Ngăn chặn hành vi mặc định để cho phép thả\r\n//         >\r\n//             {layers.map((layer, index) => {\r\n//                 let currentWidth = 100; // Kích thước mặc định cho tất cả các lớp\r\n//                 let currentHeight = 100; // Kích thước mặc định cho tất cả các lớp\r\n//                 let offsetX = 0; // Offset thêm vào vị trí X\r\n//                 let offsetY = 0; // Offset thêm vào vị trí Y\r\n\r\n//                 // Bước 1: Xác định kích thước thực tế của lớp hiện tại (100% hoặc 80%)\r\n//                 if (\r\n//                     layer.type === 'topColorSecondLayer' ||\r\n//                     (layer.type === 'topCream' && numLayers === 2) ||\r\n//                     (layer.type === 'sugar' && numLayers === 2)\r\n//                 ) {\r\n//                     currentWidth *= 0.8;\r\n//                     currentHeight *= 0.8;\r\n//                 }\r\n\r\n//                 // Bước 2: Tính toán vị trí góc trên bên trái ban đầu để căn giữa hình ảnh\r\n//                 // dựa trên kích thước hiện tại của nó (currentWidth, currentHeight)\r\n//                 let x = BASE_X_CENTER - (currentWidth / 2);\r\n//                 let y = BASE_Y_CENTER - (currentHeight / 2);\r\n\r\n//                 // Bước 3: Áp dụng các offset cụ thể mà bạn đã cung cấp\r\n//                 switch (layer.type) {\r\n//                     case 'midCream':\r\n//                         offsetY -= 22.6;\r\n//                         break;\r\n//                     case 'topColorSecondLayer':\r\n//                         offsetX += 37.6;\r\n//                         offsetY -= 61.9;\r\n//                         break;\r\n//                     case 'topCream':\r\n//                         if (numLayers === 1) {\r\n//                             offsetY -= 22.6;\r\n//                         } else if (numLayers === 2) {\r\n//                             offsetX += 37.6;\r\n//                             offsetY -= 61.9;\r\n//                         }\r\n//                         break;\r\n//                     case 'sugar':\r\n//                         if (numLayers === 1) {\r\n//                             offsetY -= 22.6;\r\n//                         } else if (numLayers === 2) {\r\n//                             offsetX += 37.6;\r\n//                             offsetY -= 61.9;\r\n//                         }\r\n//                         break;\r\n//                     default:\r\n//                         break;\r\n//                 }\r\n\r\n//                 // Bước 4: Áp dụng tổng các offset vào vị trí cuối cùng\r\n//                 x += offsetX;\r\n//                 y += offsetY;\r\n\r\n//                 let zIndex = index + 1; // Đảm bảo các lớp mới hơn nằm trên các lớp cũ hơn\r\n\r\n//                 return (\r\n//                     <Layer\r\n//                         key={layer.type} // Sử dụng layer.type làm key để đảm bảo cập nhật đúng\r\n//                         src={layer.src}\r\n//                         alt={layer.type}\r\n//                         style={{\r\n//                             position: 'absolute',\r\n//                             left: `${x}px`,\r\n//                             top: `${y}px`,\r\n//                             width: `${currentWidth}px`,\r\n//                             height: `${currentHeight}px`,\r\n//                             zIndex: zIndex,\r\n//                         }}\r\n//                     />\r\n//                 );\r\n//             })}\r\n//         </div>\r\n//     );\r\n// });\r\n\r\n// export default CakeCanvas;\r\n\r\nimport React, { forwardRef, useState, useEffect } from 'react';\r\nimport './CakeCanvas.css';\r\nimport Layer from './Layer';\r\n\r\nconst CANVAS_WIDTH = 300;\r\nconst CANVAS_HEIGHT = 300;\r\n\r\nconst CakeCanvas = forwardRef(({ layers, numLayers, onDrop }, ref) => {\r\n    const [imageSizes, setImageSizes] = useState({});\r\n\r\n    // Hàm lấy kích thước thực tế của ảnh sau khi tải\r\n    const getImageDimensions = (src) => {\r\n        return new Promise((resolve) => {\r\n            const img = new Image();\r\n            img.onload = () => {\r\n                resolve({ width: img.width, height: img.height });\r\n            };\r\n            img.src = src;\r\n        });\r\n    };\r\n\r\n    // Lấy kích thước của tất cả các ảnh khi component mount hoặc khi layers thay đổi\r\n    useEffect(() => {\r\n        const fetchSizes = async () => {\r\n            const sizes = {};\r\n            for (const layer of layers) {\r\n                if (layer.src && !sizes[layer.src]) {\r\n                    const dimensions = await getImageDimensions(layer.src);\r\n                    sizes[layer.src] = dimensions;\r\n                }\r\n            }\r\n            setImageSizes(prevSizes => ({ ...prevSizes, ...sizes }));\r\n        };\r\n\r\n        fetchSizes();\r\n    }, [layers]);\r\n\r\n    return (\r\n        <div\r\n            className=\"cake-canvas\"\r\n            style={{ width: `${CANVAS_WIDTH}px`, height: `${CANVAS_HEIGHT}px` }}\r\n            ref={ref}\r\n            onDrop={onDrop}\r\n            onDragOver={(e) => e.preventDefault()}\r\n        >\r\n            {layers.map((layer, index) => {\r\n                const originalSize = imageSizes[layer.src] || { width: 100, height: 100 };\r\n                let displayWidth = originalSize.width;\r\n                let displayHeight = originalSize.height;\r\n                const centerX = CANVAS_WIDTH / 2;\r\n                const centerY = CANVAS_HEIGHT / 2 + 50;\r\n\r\n                let offsetX = 0;\r\n                let offsetY = 0;\r\n\r\n                // Giảm kích thước hiển thị xuống 80% cho một số lớp\r\n                if (\r\n                    layer.type === 'topColorSecondLayer' ||\r\n                    (layer.type === 'topCream' && numLayers === 2) ||\r\n                    (layer.type === 'sugar' && numLayers === 2)\r\n                ) {\r\n                    displayWidth *= 0.8;\r\n                    displayHeight *= 0.8;\r\n                }\r\n\r\n                // Tính toán vị trí để căn giữa *sau khi* đã điều chỉnh kích thước hiển thị\r\n                let x = centerX - (displayWidth / 2);\r\n                let y = centerY - (displayHeight / 2);\r\n                let zIndex = index + 1;\r\n\r\n                // Áp dụng offsets của bạn dựa trên layer.type\r\n                switch (layer.type) {\r\n                    case 'midCream':\r\n                        offsetY -= 22.6;\r\n                        break;\r\n                    case 'topColorSecondLayer':\r\n                        offsetX += 37.6;\r\n                        offsetY -= 61.9;\r\n                        break;\r\n                    case 'topCream':\r\n                        offsetY -= (numLayers === 1 ? 22.6 : 61.9); // Cần bạn xác nhận offset chính xác\r\n                        break;\r\n                    case 'sugar':\r\n                        // offsetY -= (numLayers === 1 ? 22.6 : 61.9);\r\n                        offsetY -= (numLayers === 1 ? 23.6 : 61.9); // Cần bạn xác nhận offset chính xác\r\n                        break;\r\n                    // Thêm các case khác nếu cần\r\n                }\r\n\r\n                x += offsetX;\r\n                y += offsetY;\r\n\r\n                return (\r\n                    <Layer\r\n                        key={layer.type}\r\n                        src={layer.src}\r\n                        alt={layer.type}\r\n                        style={{\r\n                            position: 'absolute',\r\n                            left: `${x}px`,\r\n                            top: `${y}px`,\r\n                            width: `${displayWidth}px`,\r\n                            height: `${displayHeight}px`,\r\n                            zIndex: zIndex,\r\n                        }}\r\n                    />\r\n                );\r\n            })}\r\n        </div>\r\n    );\r\n});\r\n\r\nexport default CakeCanvas;"],"mappings":";;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAOA,KAAK,IAAIC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC9D,OAAO,kBAAkB;AACzB,OAAOC,KAAK,MAAM,SAAS;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE5B,MAAMC,YAAY,GAAG,GAAG;AACxB,MAAMC,aAAa,GAAG,GAAG;AAEzB,MAAMC,UAAU,gBAAAC,EAAA,cAAGT,UAAU,CAAAU,EAAA,GAAAD,EAAA,CAAC,CAAC;EAAEE,MAAM;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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}